<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Le D√©mineur (Minesweeper) est un jeu de r√©flexion dont le but est de localiser des mines cach√©es dans une grille repr√©sentant un champ de mines avec pour seule indication le nombre de mines dans les zones adjacentes. La r√®gle du jeu est simple : le joueur s√©lectionne une case sur la grille, et cette case r√©v√®le un nombre qui indique le nombre de mines se trouvant dans les cases adjacentes. En utilisant ces informations, le joueur doit d√©duire l‚Äôemplacement des mines et les marquer avec des drapeaux pour les √©viter."
    />
    <link rel="icon" type="image/png" href="./images/bomb-48.png" />
    <link rel="icon" type="image/png" href="./images/bomb-96.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="style.css" />
    <title>Jeu du D√©mineur</title>
  </head>

  <body>
    <div class="container">
      <div class="title">
        <h1>Jeu du D√©mineur</h1>
      </div>
      <div id="game">
        <div id="grid"></div>
      </div>
    </div>

    <script>
      const bombe = "üí£";
      const drapeau = "üö©";
      let largeur = 9;
      let hauteur = 9;
      let nbMines = 10;
      let matrice = []; // 0,1,2,3,4,5,6,7,-1 (bombes)
      let masque = []; //  1 (voile), 0 (afficher), -1 (drapeau)
      let nbDrapeaux = 0;

      /**
       * Inialisation de la matrice du jeu
       **/
      function initGame() {
        for (let i = 0; i < hauteur; i++) {
          let row = [];
          let row1 = [];
          for (let j = 0; j < largeur; j++) {
            row.push(1);
            row1.push(1);
          }
          masque.push(row);
          matrice.push(row1);
        }
        //console.table(matrice);
      }

      /**
       * G√©n√®rer la position des mines al√©atoirement
       *
       **/
      function placerMines() {
        let intervalle = largeur * hauteur; // aire
        for (let i = 0; i < nbMines; i++) {
          let positionMine;
          let row, col;
          do {
            //choisit une nouvelle position si case est deja -1
            positionMine = Math.floor(Math.random() * intervalle);
            row = Math.floor(positionMine / largeur);
            col = positionMine % largeur;
          } while (matrice[row][col] == -1);

          // place la mine dans la matrice (case -1)
          matrice[row][col] = -1;
        }
        console.log("Mines placed:", matrice);
      }

      /**
       *  Cr√©er la grille de jeu
       **/
      function createGrid() {
        let grid = document.getElementById("grid");
        let table = document.createElement("table");
        table.classList.add("minesweeper-grid");

        for (let i = 0; i < hauteur; i++) {
          let row = document.createElement("tr");
          for (let j = 0; j < largeur; j++) {
            let cell = document.createElement("td");
            cell.classList.add("cell_cachee");
            cell.id = i + "-" + j;
            cell.textContent = "";

            // Event play : left click on a cell
            cell.addEventListener("click", () => {
              jouer(i, j);
            });

            // Event flag : right click on a cell
            cell.addEventListener("contextmenu", (event) => {
              afficheDrapeau(event);
            });

            row.append(cell);
          }
          table.append(row);
        }
        grid.append(table);
      }

      /**
       * Jouer : clic gauche sur une case
       **/
      function jouer(i, j) {
        console.log("Click sur la case i et j :" + i, j);
        // ex: largeur = 9, i = 2,j = 3 => position= 2 √ó 9 + 3 =21
        // grille bidimensionnelle en tableau unidimensionnel
        let position = i * largeur + j;
        if (vecteurMines.includes(position)) {
          console.log("Mine trouv√©e! Partie perdue.");
          afficherToutesLesMines();
          return;
        }

        displayGrid();
      }

      /**
       * Affiche toutes les mines
       **/
      function afficherToutesLesMines() {
        console.log("Positions des mines :");
        for (let mine of vecteurMines) {
          let row = Math.floor(mine / largeur); // Mine a une position
          let col = mine % largeur;
          console.log("Mine √† :", row, col);
          document.getElementById(row + "-" + col).textContent = bombe;
        }
      }

      /**
       *  Effacer le style des cellules
       **/
      function effacerStyle(elem) {
        elem.classList.forEach((style_) => {
          elem.classList.remove(style_);
        });
      }

      /**
       * Affiche un drapeau ou retire un drapeau
       **/
      function afficheDrapeau(event) {
        event.preventDefault();
        const cell = event.target; // cell (td)
        if (cell.classList.contains("cell_devoilee")) {
          return; //impossible
        }
        if (cell.classList.contains("cell_drapeau")) {
          cell.classList.remove("cell_drapeau"); //retire
          cell.textContent = "";
        } else {
          nbDrapeaux++;
          cell.classList.add("cell_drapeau"); //ajoute
          cell.textContent = drapeau;
        }
        verifierGagnant();
      }

      /**
       * Return tableau des cases adjacentes aux bombes
       **/
      function voisinages_lineaires(i, j) {
        let voisinages = [];
        for (let ii = i - 1; ii <= i + 1; ii++)
          for (let jj = j - 1; jj <= j + 1; jj++) {
            if (ii < 0 || ii >= hauteur || jj < 0 || jj >= largeur) continue;
            if ((ii == i) & (jj == j)) continue;
            voisinages.push(ii * largeur + jj);
          }
        //console.log(voisinages)
        return voisinages;
      }

      /**
       * v√©rifie s'il y a un gagnant
       **/
      function verifierGagnant() {
        if (nbDrapeaux !== nbMines) return;

        let minesMarqueesParDrapeaux = true;
        // check si toutes les bombes du vecteur sont marqu√©es d'un drapeau
        for (let mine of vecteurMines) {
          let row = Math.floor(mine / largeur);
          let col = mine % largeur;
          if (
            !document
              .getElementById(row + "-" + col)
              .classList.contains("cell_drapeau")
          ) {
            minesMarqueesParDrapeaux = false;
            break;
          }
        }
        // si toutes les mines sont marqu√©s d'un drapeau
        if (minesMarqueesParDrapeaux) {
          console.log("Toutes les mines sont marqu√©es par un drapeau, gagn√©!");
          devoilerCasesSansMines();
        }
      }

      function devoilerCasesSansMines() {
        console.log("ici");
        for (let i = 0; i < hauteur; i++) {
          for (let j = 0; j < largeur; j++) {
            let position = i * largeur + j;
            //console.log("position" + position )
            if (!vecteurMines.includes(position)) {
              let cell = document.getElementById(i + "-" + j);
              //console.log(cell)
              // if cell existe et a cell_drapeau
              if (cell && cell.classList.contains("cell_drapeau")) {
                // check si la case contient un drapeau
                //cell.classList.remove("cell_drapeau");
                effacerStyle(cell);
                cell.classList.add("cell_devoilee");
                cell.textContent = "";
              }
            }
          }
        }
      }

      /**
       *  Affiche la grille de jeu
       **/
      function displayGrid() {
        for (let i = 0; i < hauteur; i++) {
          for (let j = 0; j < largeur; j++) {
            let cell = document.getElementById(i + "-" + j);
            effacerStyle(cell);

            if (false) {
              cell.classList.add("cell_cachee");
              if (matrice[i][j] === -3) {
                // placer drapeau
              }
            } else {
              cell.classList.add("cell_devoilee");
              // 1 => 'couleur1'
              // 2 => 'couleur2'
              // 3 => 'couleur3'
              // 'case'+matrice[i][j]

              cell.textContent = matrice[i][j];
              if (matrice[i][j] > 0)
                cell.classList.add("couleur" + matrice[i][j]);
            }
          }
        }
      }

      // clic droit: ajouter drapeau
      // clic mine : on perd: toutes les bombes sont d√©voil√©es dans la console
      // tester s'il a gagn√© : d√©voile toutes les cases sans mines qui sont sous drapeaux
      /*
      - Compter les drapeaux dans la grille ($counter?)
      - check si les drapeaux sont sur des mines
      - check si toutes les cellules sans mines sont d√©voil√©es
      */
      // algo r√©cursif d√©voiler cases

      /**
       *
       **/
      function remplir_chiffres() {
        for (i = 0; i < matrice.length; i++)
          for (let j = 0; j < matrice[i].length; j++) {
            // V√©rifie si la case a une bombe -1
            if (matrice[i][j] == -1) {
              //console.log(matrice[i][j]);
              continue;
            } else {
              let vecteurVoisinage = voisinages_lineaires(i, j);
              let counterMines = 0;
              for (let k = 0; k < vecteurVoisinage.length; k++) {
                let row = Math.floor(vecteurVoisinage[k] / largeur);
                let col = vecteurVoisinage[k] % largeur;
                if (matrice[row][col] == -1) {
                  counterMines++;
                }
              }
              console.log(`Mines around (${i}, ${j}): ${counterMines}`);
              matrice[i][j] = counterMines;
            }
          }
      }

      initGame();
      placerMines();
      remplir_chiffres();
      createGrid();
      displayGrid();
      console.table(matrice);

      // d√©termine les cases voisines d'une bombe d√©voil√©es // algorithme de fulfil
    </script>
  </body>
</html>
